/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

// Add a version variable to control service worker updates
const version = '1.0.0';
const CACHE_PREFIX = 'pwabuilder';
const offlineFallbackPage = 'index.html';

clientsClaim();

// This is the service worker with the combined offline experience (Offline page + Offline copy of pages)

const CACHE = "pwabuilder-offline-page";

self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

self.addEventListener('install', async (event) => {
  event.waitUntil(
    caches.open(CACHE)
      .then((cache) => cache.add(offlineFallbackPage))
  );
});

if (self.workbox.navigationPreload.isSupported()) {
  self.workbox.navigationPreload.enable();
}

self.workbox.routing.registerRoute(
  new RegExp('/*'),
  new self.workbox.strategies.StaleWhileRevalidate({
    cacheName: CACHE
  })
);

self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith((async () => {
      try {
        const preloadResp = await event.preloadResponse;

        if (preloadResp) {
          return preloadResp;
        }

        const networkResp = await fetch(event.request);
        return networkResp;
      } catch (error) {

        const cache = await caches.open(CACHE);
        const cachedResp = await cache.match(offlineFallbackPage);
        return cachedResp;
      }
    })());
  }
});

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell.
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }
    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    // If this looks like a URL for a resource, because it contains a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    // Return true to signal that we want to use the handler.
    return true;
  },
  async ({ event }) => {
    try {
      const preloadResp = await event.preloadResponse;

      if (preloadResp) {
        return preloadResp;
      }

      const networkResp = await fetch(event.request);
      return networkResp;
    } catch (error) {
      const cache = await caches.open(`${CACHE_PREFIX}-${version}`);
      const cachedResp = await cache.match(offlineFallbackPage);
      return cachedResp;
    }
  }
);

// An example runtime caching route for requests that aren't handled by the precache.
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  new StaleWhileRevalidate({
    cacheName: `${CACHE_PREFIX}-${version}-images`,
    plugins: [
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// Clean up old caches when the service worker is activated
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.filter((cacheName) => {
          // Check if the cache name matches the previous version prefix
          return cacheName.startsWith(CACHE_PREFIX) && cacheName !== `${CACHE_PREFIX}-${version}`;
        }).map((cacheName) => {
          // Delete the old cache
          return caches.delete(cacheName);
        })
      );
    })
  );
});
